using System;

using Utilities;

namespace Sample_0
{
    // 1. Способы загрузки связанных данных 
    // 2. Типы связи между таблицами
    // 3. Жизненный цикл сущности
    // 4. Отслеживание действий Entity Framework
    // 5. Поддержка транзакций в Entity Framework
    // 6. Наследование в Entity Framework
    internal class Program
    {
        static void Main(string[] args)
        {
            // Console.WriteLine(DbLibraryContext.FillAll());
            // ConsoleHelper.ConsolePause();

            //Sample_Loadins();
            //Sample_Logging();

            Sample_Transaction();
        }

        /// <summary>
        /// 1. Вывод данных с помощью трех способов загрузки данных 
        /// * Отложенная загрузка не достает сразу все связанные 
        /// данные, а доставляет их только тогда, когда выполняется их явный запрос, и только те данные, которые
        /// требуются в запросе. Использовать отложенную загрузку имеет смысл тогда, когда вам не нужны все
        /// связанные данные, а лишь некоторые из них.
        /// 
        /// * Безотложная загрузка является противоположностью 
        /// отложенной загрузки. Она сразу доставляет данные из
        /// основной сущности и из связанных сущностей. Этот
        /// способ загрузки полезен тогда, когда вам нужны все
        /// данные из связанных сущностей.
        /// 
        /// * Явная загрузка похожа на отложенную. Но она позволяет точно управлять загрузкой связанных данных 
        /// вызовом метода Load(), т.к.до явного вызова метода
        /// Load() данные из связанных сущностей не загружаются.
        /// </summary>
        private static void Sample_Loadins()
        {
            DbLibraryContext.ConsolePrintBooks_LazуLoading();
            Console.WriteLine("\n=====================\n");

            DbLibraryContext.ConsolePrintBooks_EagerLoading();
            Console.WriteLine("\n=====================\n");

            DbLibraryContext.ConsolePrintBooks_EagerLoading();
            Console.WriteLine("\n=====================\n");
            ConsoleHelper.ConsolePause();
        }

        /// 2. Типы связи между таблицыми: 
        /// * связь «один к одному»: соответствующие навигационные свойства представляют собой простые значения;
        /// * связь «один ко многим»: в одной сущности используется внешний ключ, а в другой — коллекция типа ICollection<T>;
        /// * связь «многие ко многим»: обе сущности содержат коллекции ICollection<T>.


        /// 3. Жизненный цикл сущности
        /// Во время работы состояние сущности изменяется, эти состояния определены в перечислении System.Data.
        /// EntityState, которое содержит следующие значения:
        public enum EntityState
        {
            Detached = 1,
            Unchanged = 2,
            Added = 4,
            Deleted = 8,
            Modified = 16,
        }
        /// При работе с сущностями важную роль выполняет метод SaveChanges(), предназначенный для синхронизации состояния сущности и соответствующих таблиц в БД.
        /// Состояния сущности: 
        /// * Состояние Detached — сущность не отслеживается 
        /// контекстом БД(не присоединена к контексту). 
        /// * Состояние Unchanged — сущность отслеживается
        /// контекстом БД и находится в БД, и значения всех ее
        /// свойств не изменены по сравнению со значениями в БД.
        /// * Состояние Added  — сущность уже отслеживается
        /// (управляется) контекстом БД, но еще не добавлена в БД.
        /// * Состояние Deleted — сущность еще отслеживается
        /// контекстом БД и еще находится в БД, но она уже была
        /// помечена на удаление и будет удалена при следующем
        /// вызове метода SaveChanges().
        /// * Состояние Modified  — сущность отслеживается
        /// контекстом БД и находится в БД, но значения некоторых ее свойств были изменены по сравнению со
        /// значениями в БД.
        /// Примеры состояний можно посмотреть в методичке


        /// 4.Отслеживание действий Entity Framework
        /// В Entity Framework встроен механизм ведения лога.
        /// У контекста есть свойство Database, у которого в свою очередь, есть свойство Log.
        /// Тип этого свойства Action<string>. 
        /// Если вы хотите управлять процессом логгирования, все что вам 
        /// нужно сделать — это создать метод с одним стринговым параметром
        /// и типом возвращаемого значения void и инициализировать
        /// адресом этого метода свойство контекста database.Log.
        /// Например: db.Database.Log = Console.Write;
        private static void Sample_Logging()
        {
            DbLibraryContext.AddAuthor_Log(new Author()
            {
                FirstName = "FirstName Test Log",
                LastName = "LastName Test Log"
            });

            ConsoleHelper.ConsolePause();
        }

        /// 5. Поддержка транзакций в Entity Framework
        /// Этот механизм реализован методами 
        /// Database.BeginTransaction() и Database.UseTransaction()
        /// и позволяет, в частности, выполнять в рамках одной
        /// транзакции несколько разных действий.
        private static void Sample_Transaction()
        {
            Console.WriteLine(DbLibraryContext.AuthorTransaction());
            ConsoleHelper.ConsolePause();
        }

        /// 6. Наследование в Entity Framework
        /// - Первый способ отображения такой иерархии классов 
        /// в Entity Framework называется Table per concrete type
        /// (или TPC). Это можно перевести как «таблица для каждого конкретного типа».
        /// При таком подходе для  каждого класса в БД будет создана отдельная таблица,
        /// и мы в итоге получим три таблицы. Это приведет к тому, что в некоторых случаях,
        /// когда нас будут интересовать все фигуры(и прямоугольники и окружности), в запросе
        /// будут задействованы все три таблицы.
        /// При TPC отображении для абстрактных классов таблицы не создаются.
        /// Если в вашем базовом абстрактном классе объявлены какие-либо свойства,
        /// то эти свойства будут перенесены в производные классы. Нужно 
        /// отметить, что отображение наследования способом
        /// TPC поддерживается только при подходе код сначала
        /// (Code First).
        /// Рисунок 4.
        ///
        /// - Второй способ отображения в БД связанных классов 
        /// называется Table per type(или TPT), что можно перевести
        /// как «таблица для каждого типа». В этом случае для нашего 
        /// примера будет создано три таблицы. Одна таблица будет
        /// содержать информацию, соответствующую базовому
        /// классу Point и общие для всех классов данные. 
        /// А дополнительные таблицы, соответствующие классам Rectangle
        /// и Circle, будут содержать только данные, специфичные
        /// для каждого производного класса. Такой подход удобен
        /// в том случае, когда чаще всего при обращении к БД будет
        /// требоваться информация, относящаяся к базовому типу
        /// Рисунок 5.
        /// 
        /// - Третий способ называется Table per hierarchy (или 
        /// TPH), что переводится как «таблица для иерархии». Этот
        /// способ заключается в том, что фреймворк создает одну
        /// таблицу для своей группы связанных классов.В такой
        /// таблице создается специальное поле Discriminator, в котором указывается, к какому из классов относится данная
        /// строка.При таком подходе необходимо следить за тем,
        /// чтобы все добавленные свойства производных классов
        /// принадлежали к nullable типам
        /// Рисунок 6.
    }
}
